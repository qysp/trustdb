<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Home</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Home</h1>

    



    


    <h3> </h3>










    




    <section>
        <article><h1>TrustDB</h1><h2>Getting started</h2><p>So far not available on <a href="https://npmjs.org">npm</a> but soon<code>.tm</code> fosure.</p>
<pre class="prettyprint source lang-js"><code>const db = require('trustdb');</code></pre><p>For all of the upcoming examples I'm gonna assume it happens in an asynchronous block, i.e. function.</p>
<p>Connect to the database, given a filepath and desired settings.</p>
<pre class="prettyprint source lang-js"><code>await db.connect('/path/to/file.json', {
  autosave: true, // default: false
  autosaveInterval: 10000, // in ms; default: 4000
});</code></pre><p>Create a collection.</p>
<pre class="prettyprint source lang-js"><code>const repoCollection = await db.createCollection('repoCollection');</code></pre><p>Optional: add event listeners for events like <code>autosave</code>, <code>insert</code>, <code>find</code>, <code>remove</code> or <code>update</code>.</p>
<pre class="prettyprint source lang-js"><code>// Parameter `err` will be undefined on success.
db.on('autosave', err => {
  if (err instanceof Error) {
    console.error(err);
  }
});

// Asynchronous events are allowed too!
repoCollection.on('insert', async (insertedDocs, allDocs) => {
  console.log(`Number of documents in ${repoCollection.name} after insert: ${allDocs.length}`);
  await db.save();
});

// `matchingDocs` will always be an array, even if `findOne` method has been used.
// `filter` could be a function or query object.
repoCollection.on('find', (filter, matchingDocs, allDocs) => {
  // Assuming variable `cache` has been defined as an array somewhere.
  cache.push({
    filter: filter,
    results: results,
  });
});

// `removedDocs` will always be an array, even if `removeExact` method has been used.
repoCollection.on('remove', (removedDocs, allDocs) => {
  console.log(`Number of documents removed from ${repoCollection.name}: ${removedDocs.length}`);
});

repoCollection.on('update', (updatedDocs, allDocs) => {
  console.log(`Number of updated documents in ${repoCollection.name}: ${updatedDocs.length}`);
});</code></pre><p>Insert documents.</p>
<pre class="prettyprint source lang-js"><code>// Some example documents.
const repositories = [{
    url: 'https://github.com/qysp/trustdb',
    title: 'trustdb',
    description: 'Promise-based, lightweight in-memory and persistent JavaScript/JSON database.'
  }, {
    url: 'https://github.com/techfort/LokiJS',
    title: 'LokiJS',
    description: 'Fast document oriented javascript in-memory database'
}];

// Insert them as an array or each document as an individual parameter.
await repoCollection.insert(repositories);

// You can also just insert a single document.
await repoCollection.insert({
  url: 'https://github.com/nodejs/node',
  title: 'Node.js',
  description: 'Node.js is a JavaScript runtime built on Chrome\'s V8 JavaScript engine.'
});</code></pre><p>Search for documents.</p>
<pre class="prettyprint source lang-js"><code>// Use query objects or custom filter functions to find matching documents.
await repoCollection.find({ description: { regExp: /lightweight/ } });
await repoCollection.find(doc => /lightweight/.test(doc.description));

await repoCollection.findOne({ title: { regExp: /js$/i } });
await repoCollection.findOne(doc => /js$/i.test(doc.description));</code></pre><p>Remove documents.</p>
<pre class="prettyprint source lang-js"><code>// Remove all documents that match the given object.
// Pass in `true` as the second parameter to only remove the first matching document.
await repoCollection.removeExact({
  url: 'https://github.com/nodejs/node',
  title: 'Node.js',
  description: 'Node.js is a JavaScript runtime built on Chrome\'s V8 JavaScript engine.'
});

// Remove all documents that match the query or pass the custom filter function.
await repoCollection.remove({ title: { re: /js$/i } });
await repoCollection.remove(doc => doc.title.startsWith('trust'));

// Remove the first document that matches the query or passes the custom filter function.
await repoCollection.removeOne({ title: { re: /js$/i } });
await repoCollection.removeOne(doc => doc.title.startsWith('trust'));</code></pre><p>Update documents.</p>
<pre class="prettyprint source lang-js"><code>// Update all documents that match the query with another object.
await repoCollection.update(
  { description: { regExp: /database/ } },
  { tags: [ 'database' ] }
);

// Update all documents with your own custom filter and update functions.
await repoCollection.update(
  doc => /runtime/.test(doc.description),
  doc => doc.tags = [ 'runtime' ]
);

// But you can obviously also combine the two features.
await repoCollection.update(
  doc => /runtime/.test(doc.description),
  { tags: [ 'runtime' ] }
);</code></pre><h2>Query functions</h2><ul>
<li>equal</li>
<li>notEqual</li>
<li>strictEqual</li>
<li>strictNotEqual</li>
<li>deepStrictEqual</li>
<li>deepStrictNotEqual</li>
<li>greaterThan</li>
<li>lessThan</li>
<li>greaterThanOrEqual</li>
<li>lessThanOrEqual</li>
<li>startsWith</li>
<li>endsWith</li>
<li>typeOf</li>
<li>lengthOf</li>
<li>between</li>
<li>regExp</li>
<li>dateCompare</li>
<li>hasProperty</li>
<li>includes</li>
<li>notIncludes</li>
<li>instanceOf</li>
</ul>
<h3>Usage examples:</h3><p>All of these same queries can of course also be applied to the <code>findOne</code>, <code>remove</code> and <code>update</code> methods!</p>
<p>In these examples we will find all documents, where the value of <code>propertyA</code> or the property itself:</p>
<pre class="prettyprint source lang-js"><code>// equals 30, 30.0, '30', etc.
collection.find({ propertyA: { equal: 30 } });

// equals exactly 30
collection.find({ propertyA: { strictEqual: 30 } });
collection.find({ propertyA: 30 })

// is the exact same object { a: 1 }
collection.find({ propertyA: { deepStrictEqual: { a: 1 } } });

// ends with 'ing'
collection.find({ propertyA: { endsWith: 'ing' } });

// is of type 'number' (only primitive types and array)
collection.find({ propertyA: { typeOf: 'number' } });

// has the length of 5 (array, string or set)
collection.find({ propertyA: { lengthOf: 5 } });

// is between 5 and 10 (order of the numbers does not matter)
collection.find({ propertyA: { between: [ 5, 10 ] } });

// matches the regex pattern 'something', case insensitive
collection.find({ propertyA: { regExp: /something/i } });

// equals the date '1/1/1970' (can also be a Date object)
collection.find({ propertyA: { dateCompare: '1/1/1970' } });

// does not exist
collection.find({ propertyA: { hasProperty: false } });

// does not include 10 (array or set)
collection.find({ propertyA: { notIncludes: 10 } });

// is an instance of Date
collection.find({ propertyA: { instanceOf: Date } });</code></pre><h3>Advanced usage examples:</h3><p>You can use logical operators which will concatenate the result of queries for a specific property.
For example, <code>and</code>, which is the default, makes sure every query result is truthy or the document won't pass.
On the other hand, <code>or</code> will make sure that at least one of the query results is truthy.</p>
<p>The available logical operators are:</p>
<ul>
<li>and</li>
<li>not</li>
<li>or</li>
<li>nor</li>
</ul>
<p>To utilize one of these logical operators, assign it to the property <code>$op</code> (standing for <em>operator</em>).</p>
<p>Furthermore, it is also possible to apply a logical operator to a specific property aka. it's queries.</p>
<p>Usage of the logical operator <code>or</code> to concatenate each query result.</p>
<pre class="prettyprint source lang-js"><code>collection.find({
  propertyA: { startsWith: 'duck' },
  propertyB: { endsWith: 'ing' },
  $op: 'or'
});</code></pre><p>Explanation: this will return all documents which have a property named <code>propertyA</code> with a value that starts with <em>duck</em> <strong>or</strong> <code>propertyB</code> with a value that ends with <em>ing</em>.</p>
<p>Usage of the logical operator <code>not</code> to concatenate each query result as well as the operator <code>or</code> within the query for the property <code>propertyA</code>.</p>
<pre class="prettyprint source lang-js"><code>collection.find({
  propertyA: {
    startsWith: 'duck',
    endsWith: 'duck',
    $op: 'or'
  },
  propertyB: { endsWith: 'ing' },
  $op: 'not'
});</code></pre><p>Explanation: this will return all documents which do <strong>not</strong> have a property named <code>propertyA</code> with a value that starts <strong>or</strong> ends with <em>duck</em> and <code>propertyB</code> with a value that ends with <em>ing</em>.</p></article>
    </section>






</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Collection.html">Collection</a></li><li><a href="TrustDB.html">TrustDB</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.5</a> on Tue May 07 2019 21:43:06 GMT+0200 (Central European Summer Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>