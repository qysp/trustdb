<!-- start:source.tmpl.hbs -->
<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width">
		<title>trustdb.js</title>
		<!--[if lt IE 9]>
		<script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
		<![endif]-->
		<link href="https://fonts.googleapis.com/css?family=PT+Mono" rel="stylesheet">
		<link type="text/css" rel="stylesheet" href="css/bootstrap.min.css">
		<link type="text/css" rel="stylesheet" href="css/prism.min.css">
		<link type="text/css" rel="stylesheet" href="css/template.min.css">
		<script type="text/javascript">
			window.TEMPLATE_OPTIONS = {"includeDate":true,"dateFormat":"Do MMM YYYY","systemName":"FooDoc","systemSummary":"A Bootstrap and Handlebars based template for JSDoc3.","systemLogo":"","systemColor":"","navMembers":[{"kind":"class","title":"Classes","summary":"All documented classes."},{"kind":"external","title":"Externals","summary":"All documented external members."},{"kind":"global","title":"Globals","summary":"All documented globals."},{"kind":"mixin","title":"Mixins","summary":"All documented mixins."},{"kind":"interface","title":"Interfaces","summary":"All documented interfaces."},{"kind":"module","title":"Modules","summary":"All documented modules."},{"kind":"namespace","title":"Namespaces","summary":"All documented namespaces."},{"kind":"tutorial","title":"Tutorials","summary":"All available tutorials."}],"footer":"","copyright":"FooDoc Copyright © 2016 The contributors to the JSDoc3 and FooDoc projects.","linenums":true,"collapseSymbols":true,"inverseNav":true,"inlineNav":false,"outputSourceFiles":true,"sourceRootPath":null,"disablePackagePath":true,"outputSourcePath":false,"showTableOfContents":true,"showAccessFilter":true,"analytics":null,"methodHeadingReturns":true,"sort":"linenum, longname, version, since","search":true,"favicon":null,"stylesheets":[],"scripts":[],"monospaceLinks":false,"cleverLinks":false};
			window.DOCLET_TOC_ENABLED = false;
			window.DOCLET_AFILTER_ENABLED = false;
		</script>
</head>
<body>
	<!-- start:navbar.hbs -->
	<header class="navbar navbar-default navbar-fixed-top navbar-inverse">
		<div class="container">
			<div class="navbar-header">
				<a class="navbar-brand" href="index.html">
					FooDoc
				</a>
				<!-- displayed on small devices -->
				<button class="navbar-toggle" type="button" data-toggle="collapse" data-target="#topNavigation">
					<span class="icon-bar"></span>
					<span class="icon-bar"></span>
					<span class="icon-bar"></span>
				</button>
			</div>
			<div class="navbar-collapse collapse" id="topNavigation">
				<ul class="nav navbar-nav">
								<li class="dropdown">
									<a href="list_class.html" class="dropdown-toggle" data-toggle="dropdown">Classes<b class="caret"></b></a>
									<ul class="dropdown-menu">
											<li><a href="Collection.html">Collection</a></li>
											<li><a href="Result.html">Result</a></li>
											<li><a href="TrustDB.html">TrustDB</a></li>
									</ul>
								</li>
				</ul>
					<!-- start:lunr-search-navbar.hbs -->
					<form class="navbar-form navbar-right" role="search">
						<div class="input-group">
							<input type="text" class="form-control" placeholder="Search" id="lunr-search-input">
							<div class="input-group-btn">
								<button class="btn btn-default" id="lunr-search-submit">
									<i class="glyphicon glyphicon-search"></i>
								</button>
							</div>
						</div>
					</form>
					<!-- start:lunr-search-navbar.hbs -->		</div>
		</div>
	</header>
	<!-- end:navbar.hbs -->		<div class="page-header">
			<div class="container">
				<span class="kind">source</span>
				<h1><span class="name">trustdb.js</span></h1>
			</div>
		</div>
	<div class="container content">
		<div class="row">
			<div class="col-md-12 main-content">
		<section class="source-section">
			<article></article>
			<pre class="prettyprint source language-javascript line-numbers"><code class="language-javascript">const fs = require('fs');
const { promisify } = require('util');

const Collection = require('./collection');
const EventEmitter = require('./events');
const { isPlainObject, mkdirp } = require('./helpers');

// Promisify asynchronous functions
const writeFile = promisify(fs.writeFile);
const readFile = promisify(fs.readFile);
const copyFile = promisify(fs.copyFile);
const unlink = promisify(fs.unlink);
const stat = promisify(fs.stat);

/**
 * Creates an TrustDB instance.
 * 
 * @extends EventEmitter
 * @borrows TrustDB#saveDatabase as TrustDB#save
 */
class TrustDB extends EventEmitter {
  constructor() {
    super();
    this._events = {
      'autosave': [],
    };
  }

  /**
   * Create a connection to a new database. If the file in the `filepath` already exists,
   * it will be loaded and the collections (and optionally the settings, too)
   * will be applied to this instance, unless the setting `overwriteExisting` is set to true.
   * 
   * @param {string} filepath database filepath
   * @param {object} [settings={}] database related optional settings
   * @param {boolean} [settings.autosave] whether the database should be automatically saved
   * @param {number} [settings.autosaveInterval] interval for the autosave in milliseconds
   * @param {boolean} [settings.restoreSettings] whether TrustDB should restore settings from the loaded database (if it exists)
   * @param {boolean} [settings.overwriteExisting] whether the existing database with the same filepath (if it exists) should be overwritten
   * @returns {Promise&lt;void | Error>} a Promise that resolves after everything is configured and set up
   */
  connect(filepath, settings = {}) {
    return new Promise(async (resolve, reject) => {
      if (typeof filepath !== 'string' || filepath === '') {
        reject(new Error('Parameter `filepath` must be a string and at least one character long'));
        return;
      }

      this.filepath = filepath;
      this.created = new Date().toISOString();
      this._collections = [];

      this.settings = {};
      this._autosave = false;
      this._autosaveInterval = 4000;
      this.autosaveHandler;

      if (settings.overwriteExisting !== true) {
        await this._restoreDatabase(settings).catch(reject);
      }

      this.configureSettings(this.settings);
      resolve();
    });
  }

  /**
   * Create a collection with the given name. Returns an existing collection
   * in case a collection with the same name already eixists in this database.
   * 
   * Use {@link TrustDB#deleteCollection} before creating or adding a collection with the same name.
   * 
   * @param {string} name name of the collection
   * @returns {Promise&lt;Collection | Error>} a Promise with the created collection or exisiting collection with the same name
   */
  createCollection(name) {
    return new Promise((resolve, reject) => {
      if (typeof name !== 'string' || name === '') {
        reject(new TypeError('Parameter `name` must be a string and at least one character long'));
        return;
      }

      let collection = this._collections.find(c => c.name === name);
      if (collection === undefined) {
        collection = new Collection(name);
        this._collections.push(collection);
      }

      resolve(collection);
    });
  }

  /**
   * IMPORTANT: This function does **not** create a new collection. Use {@link TrustDB#createCollection} to create a new collection.
   * 
   * Add a collection to the database. Returns an existing collection
   * in case a collection with the same name already eixists in this database.
   * 
   * Use {@link TrustDB#deleteCollection} before creating or adding a collection with the same name.
   * 
   * @param {Collection} collection collection instance to add
   * @returns {Promise&lt;Collection | Error>} a Promise with the added collection or exisiting collection with the same name
   */
  addCollection(collection) {
    return new Promise((resolve, reject) => {
      if (!(collection instanceof Collection)) {
        reject(new TypeError('Parameter `collection` must be an instance of Collection'));
      }

      let foundCollection = this._collections.find(c => c.name === collection.name);

      if (foundCollection === undefined) {
        this._collections.push(collection);
      } else {
        collection = foundCollection;
      }

      resolve(collection);
    });
  }

  /**
   * Delete a collection with the given name or a Collection instance.
   * 
   * @param {Collection | string} collection name of the collection or a Collection instance
   * @returns {Promise&lt;Collection | Error>} a Promise with the deleted collection
   */
  deleteCollection(collection) {
    return new Promise((resolve, reject) => {
      const name = collection instanceof Collection
        ? collection.name
        : collection;

      if (typeof name !== 'string' || name === '') {
        reject(new TypeError('Parameter `name` must be a string and at least one character long'));
        return;
      }

      const idx = this._collections.findIndex(c => c.name === name);

      if (idx === -1) {
        reject(new Error('No collection with that name was found'));
        return;
      }

      const removed = this._collections.splice(idx, 1);
      resolve(...removed);
    });
  }

  /**
   * Retrieve a collection by name.
   * 
   * @param {string} name name of the collection
   * @returns {Promise&lt;Collection | Error>} a Promise with the matching collection
   */
  getCollection(name) {
    return new Promise((resolve, reject) => {
      if (typeof name !== 'string' || name === '') {
        reject(new TypeError('Parameter `name` must be a string and at least one character long'));
        return;
      }

      const collection = this._collections.find(c => c.name === name);

      if (collection === undefined) {
        reject(new Error('No collection with that name was found'));
        return;
      }

      resolve(collection);
    });
  }

  /**
   * Save the database with its collections,
   * settings and metadata to the specified file.
   * 
   * @returns {Promise&lt;void | Error>} a Promise which resolves after saving the database
   */
  saveDatabase() {
    return new Promise((resolve, reject) => {
      const exportedDb = this._exportDatabase();

      mkdirp(this.filepath)
        .then(() => writeFile(this.filepath, exportedDb))
        .then(resolve)
        .catch(reject);
    });
  }

  /**
   * Delete the database from the filesystem if it exists.
   * 
   * @returns {Promise&lt;void | Error>} a Promise which resolves after the deletion
   */
  deleteDatabase() {
    return new Promise((resolve, reject) => {
      stat(this.filepath)
        .then(stats => {
          if (!stats.isFile()) {
            reject(new Error('Database requested to delete is not a file'));
          }
        })
        .then(() => unlink(this.filepath))
        .then(resolve)
        .catch(err => {
          if (err.code !== 'ENOENT') {
            reject(err);
          }
          resolve();
        });
    });
  }

  /**
   * Move the database to the new path on the filesystem.
   * 
   * @param {string} filepath new path for the database
   * @returns {Promise&lt;void | Error>} a Promise which resolves after moving the database
   */
  moveDatabase(filepath) {
    return new Promise((resolve, reject) => {
      if (typeof filepath !== 'string' || filepath === '') {
        reject(new TypeError('Parameter `filepath` must be a string and at least one character long'));
        return;
      }
      if (this.filepath === filepath) {
        resolve();
      }

      stat(this.filepath)
        .then(stats => {
          if (!stats.isFile()) {
            reject(new Error('Database requested to move is not a file'));
          }
        })
        .catch(err => {
          if (err.code !== 'ENOENT') {
            reject(err);
          }
          // File does not exist so just change the filepath.
          this.filepath = filepath;
          resolve();
        });

      mkdirp(filepath)
        .then(() => copyFile(this.filepath, filepath))
        .then(() => unlink(this.filepath))
        .then(() => {
          this.filepath = filepath;
          resolve();
        })
        .catch(reject);
    });
  }

  /**
   * Clear the database by deleting all of its collections.
   */
  clear() {
    this._collections.length = 0;
  }

  /**
   * (Re-)Configure the settings.
   * 
   * @param {object} [settings={}] database settings
   * @param {boolean} [settings.autosave] whether the database should be automatically saved
   * @param {number} [settings.autosaveInterval] interval for the autosave in milliseconds
   */
  configureSettings(settings = {}) {
    if (!isPlainObject(settings)) {
      // Keep default configurations.
      return;
    }

    if (settings.hasOwnProperty('autosave') &amp;&amp; typeof settings.autosave === 'boolean') {
      // Actually turn off autosave.
      if (this._autosave &amp;&amp; !settings.autosave) {
        this._disableAutosave();
      }
      this._autosave = settings.autosave;
    }

    if (settings.hasOwnProperty('autosaveInterval') &amp;&amp; typeof settings.autosaveInterval === 'number') {
      this._autosaveInterval = settings.autosaveInterval;
    }

    if (this._autosave) {
      // In case the settings were reconfigured.
      if (this.autosaveHandler !== undefined) {
        this._disableAutosave();
      }
      this._enableAutosave();
    }
  }

  // ---------------------------------- Getter and Setter ----------------------------------

  /**
   * Get all collections of the database.
   * 
   * @returns {object[]} all collections of the database
   */
  get collections() {
    return this._collections;
  }

  /**
   * Get the amount of collections of the database.
   * 
   * @returns {number} amount of collections of the database
   */
  get size() {
    return this._collections.length;
  }

  /**
   * Get the amount of documents of all collections.
   * 
   * @returns {number} amount of documents of all collections
   */
  get totalSize() {
    return this._collections
      .map(c => c.size)
      .reduce((acc, curr) => acc + curr);
  }

  /**
   * Get the current state of autosave.
   * 
   * @returns {boolean} whether autosave is enabled or disabled
   */
  get autosave() {
    return this._autosave;
  }

  /**
   * Get the current autosave interval.
   * 
   * @returns {number} autosave interval in milliseconds
   */
  get autosaveInterval() {
    return this._autosaveInterval;
  }

  /**
   * Enable or disable autosave.
   * 
   * @param {boolean} value whether to enable or disable autosave
   */
  set autosave(value) {
    this.configureSettings({ autosave: value});
  }

  /**
   * Set a new autosave interval.
   * 
   * @param {number} value the new interval in milliseconds
   */
  set autosaveInterval(value) {
    this.configureSettings({ autosaveInterval: value});
  }

  // ---------------------------------- Internal functions ----------------------------------

  /**
   * Internal function.
   * 
   * Turn the database into a JSON string.
   * 
   * @returns {string} database as JSON string
   */
  _exportDatabase() {
    return JSON.stringify({
      filepath: this.filepath,
      collections: this._collections.map(c => c._export()),
      settings: {
        autosave: this._autosave,
        autosaveInterval: this._autosaveInterval,
      },
      metadata: {
        created: this.created,
        saved: new Date().toISOString(),
      },
    });
  }

  /**
   * Internal function.
   * 
   * Load a database from a file and parse its content.
   * 
   * @returns {Promise&lt;object | Error>} a Promise with the parsed database
   */
  _loadDatabase() {
    return new Promise((resolve, reject) => {
      stat(this.filepath)
        .then(stats => {
          if (!stats.isFile()) {
            reject(new Error('Database requested to delete is not a file'));
          }
        })
        .then(() => readFile(this.filepath, { encoding: 'utf-8' }))
        .then(content => resolve(JSON.parse(content)))
        .catch(reject);
    });
  }

  /**
   * Internal function.
   * 
   * Apply the collections and other data of a database object.
   * 
   * @param {object} db parsed JSON database
   * @param {boolean} restoreSettings whether to restore the 'old' settings
   */
  _applyDatabase(db, restoreSettings) {
    if (db.hasOwnProperty('metadata') &amp;&amp;
        db.metadata.hasOwnProperty('created')) {
      this.created = db.metadata.created;
    }

    // TODO: type checks
    if (Array.isArray(db.collections)) {
      this._collections = db.collections.map(c => {
        const collection = new Collection(c.name);
        collection._documents = c.documents;
        return collection;
      });
    }

    if (restoreSettings === true) {
      Object.assign(this.settings, db.settings);
    }
  }

  /**
   * Internal function.
   * 
   * Try to restore a database if it exists.
   * 
   * @param {object} settings user settings
   */
  _restoreDatabase(settings) {
    return new Promise((resolve, reject) => {
      this._loadDatabase()
        .then(db => {
          this._applyDatabase(db, settings.restoreSettings);
          resolve();
        })
        .catch(err => {
          // File exists but an error occured.
          if (err.code !== 'ENOENT') {
            reject(err);
          }
          resolve();
        })
        .finally(() => {
          Object.assign(this.settings, settings);
        });
    });
  }

  /**
   * Internal function.
   * 
   * Enables the autosave handler.
   * 
   * @fires TrustDB#autosave after autosaving (might not be successful)
   */
  _enableAutosave() {
    if (this.autosaveHandler !== undefined) {
      return;
    }

    this.autosaveHandler = setInterval(async () => {
      const result = await this.saveDatabase().catch(err => err);
      await this.emit('autosave', result);
    }, this._autosaveInterval);
  }

  /**
   * Internal function.
   * 
   * Disables the autosave handler.
   */
  _disableAutosave() {
    if (this.autosaveHandler !== undefined) {
      clearInterval(this.autosaveHandler);
      this.autosaveHandler = undefined;
    }
  }
}

// Aliases
TrustDB.prototype.save = TrustDB.prototype.saveDatabase;

module.exports = TrustDB;</code></pre>
		</section>
			</div>
		</div>
	</div>
	<footer>
				<div class="copyright">FooDoc Copyright © 2016 The contributors to the JSDoc3 and FooDoc projects.</div>
			<div class="generated-by">Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.2</a> on 12th Jun 2019 using the <a href="https://github.com/steveush/foodoc">FooDoc template</a>.</div>
	</footer>
	<script src="js/jquery.min.js"></script>
	<script src="js/bootstrap.min.js"></script>
	<script src="js/clipboard.min.js"></script>
	<script src="js/prism.min.js"></script>
	<script src="js/template.min.js"></script>
		<!-- start:lunr-search-modal.hbs -->
		<div class="modal fade" id="lunr-search-modal">
			<div class="modal-dialog">
				<div class="modal-content">
					<div class="modal-header">
						<button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>
						<h4 class="modal-title">Search results</h4>
					</div>
					<div class="modal-body" id="lunr-search-body">
					</div>
					<div class="modal-footer" id="lunr-search-footer">
						<button type="button" class="btn btn-default" data-dismiss="modal">Close</button>
					</div>
				</div><!-- /.modal-content -->
			</div><!-- /.modal-dialog -->
		</div>
		<!-- end:lunr-search-modal.hbs -->		<script src="js/lunr.min.js"></script>
	
</body>
</html>
<!-- end:source.tmpl.hbs -->